# 专业术语

[[toc]]


## Flag

* 英语词汇 [http://testyourvocab.com](http://testyourvocab.com)
* [https://testyourculture.com](https://testyourculture.com)
* [https://liuxue.ef.com.cn/epi](https://liuxue.ef.com.cn/epi)
* [https://freerice.com/categories/english-vocabulary](https://freerice.com/categories/english-vocabulary)
* [https://sourceforge.net/projects/stardict-4](https://sourceforge.net/projects/stardict-4)
    * [https://github.com/huzheng001](https://github.com/huzheng001)
* [https://oldwestenglish.github.io/grammar](https://oldwestenglish.github.io/grammar)
* 黑客背单词 [https://sourceforge.net/projects/reciteword](https://sourceforge.net/projects/reciteword)
* [https://github.com/JuanitoFatas/Computer-Science-Glossary](https://github.com/JuanitoFatas/Computer-Science-Glossary)
* [编程开发常用词汇](https://blog.csdn.net/qq_31136349/article/details/110938087)
* [认知](https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&__biz=MzU2MTgxODgwNA==&album_id=1913317802694737924)


## 中文

- 出栈
- 入栈
- 压栈
- 可变性
- 偏移性
- 有状态对象(Stateful Bean)
- 无状态对象(Stateless Bean)
- 域
- 泛型
- 进制
- 补码
- 原码
- 反码
- zigzag
- 显式声明和隐式声明
- 形参/实参
- 重载/重构/重写
- 覆盖/覆写
- 指令重排
- 内存屏障
- 原子性
- 可见性
- 有序性
- Volatile
- 弱类型： 允许不兼容的类型进行运算，如数字除字符串是合法的
- 强类型
- 动态类型：声明一个变量之后，可以存储（指向）不同类型，如变量可以一会是字符串，一会是浮点
- 静态类型
- 增量更新/热更新/强更新/差量更新
- 编码
- 编译
- 序列
- 队列
- 侧加载
- 代码管理
- 冒烟测试
- 回归测试
- 持续测试
- 功能测试
- 集成测试
- 系统测试
- 单元测试
- 基准测试
- 模糊测试
- 持续开发
- 持续集成
- 持续构建
- 持续部署
- 持续监控
- 敏捷流程
- 哨兵（Sentinel）
- 从节点（replication/replica/slave）
- 全限定类名
- 非限定类名
- 解构（Destructuring）
- 展开运算符（Spread Operator）
- FFI(Foreign Function Interface) 编程语言交互接口
- ABI(Application Binary Interface) 应用程序二进制接口
- 材料化视图（实体化视图、物化视图） 一种特殊的数据库视图
- 索引视图
- 分区视图
- 类型推断/类型推理/类型推导(Type inference/Type deduction)
- 抽象数据类型（ADT，Abstract Data Type）
- 边缘平台架构（edge platform）
- 巴士因子：一支团队里有多少成员意外被巴士撞了（或者受其他偶发因素影响而无法继续工作），才会导致项目陷入停滞。
- MCDC测试覆盖率：确定代码修改条件的决策覆盖率。也就是说测试必须保证所生成二进制代码中的每个分支操作至少跑通一次。
- 正向代理-传统模式
- 正向代理-透明模式
- 反向代理模式
- 负载均衡（Load Balancing）
- 代码检查工具（Linter）
- 副作用 (Side Effects)
- 竞争条件 (Race Conditions)
- 隔离性 (Isolation)
- 清晰性 (Clarity)
- 安全性 (Safety)
- Friendly Enough Expression Language （FEEL） 旨在以业务专业人员和开发人员都易于理解的方式编写表达式
- OGSA（Open Grid Services Architecture）是开放网络服务框架，定义了网格服务（Grid Services）的概念
- 代码走查(code walkthrough)
- 代码审查(code inspection) 


## 英文

* [程序员工作中常见的英语词汇](https://github.com/Wei-Xia/most-frequent-technology-english-words)


- `CURD`
- `CRUD`



**常用词汇**

- `add`
- `edit`
- `delete`
- `del`
- `query`
- `get`
- `select`
- `insert`
- `write`
- `read`
- `out`
- `input`
- `in`
- `of`
- `for`
- `by`
- `exist`
- `not`
- `is`
- `and`
- `has`
- `is`
- `can`
- `allow`
- `defunct`
- `orig`
- `target`
- `dest`
- `source`
- `notice`
- `inform`
- `notify`
- `notification`
- `apprize`
- `native`
- `local`
- `locale`
- `location`
- `retrieve`
- `this`
- `self`
- `cls`
- `clz`
- `class`
- `clazz`
- `sideload`
- `Sideloading` 旁加载/侧加载
- `chaos` 混沌测试
- `CookieJar` HTTP 请求时存储和管理cookies，同CookieManager、BasicCookieStore
- `MonoRepo` 单仓库模式
- `PolyRepo`/`MultiRepo` 多仓库模式
- `Hoisting` 依赖提升


**月份/星期**

- 一月：January（Jan）
- 二月：February（Feb）
- 三月：March（Mar）
- 四月：April（Apr）
- 五月：May（May）
- 六月：June（Jun）
- 七月：July（Jul）
- 八月：August（Aug）
- 九月：September（Sept）
- 十月：October（Oct）
- 十一月：November（Nov）
- 十二月：December（Dec）
- 星期一：Monday（Mon）
- 星期二：Tuesday（Tues）
- 星期三：Wednesday（Wed）
- 星期四：Thursday（Thur）
- 星期五：Friday（Fri）
- 星期六：Saturday（Sat）
- 星期日：Sunday（Sun）


## 编程语言代际

> 计算机科学界通常根据编程语言距离底层硬件的远近（即**抽象程度**）以及其发展历史，将编程语言划分为五个代际（Generations of Programming Languages，简称 1GL 到 5GL）。随着代际的更迭，编程语言越来越接近人类自然语言，开发效率不断提高，但对底层硬件的控制力相应减弱。


|  代际 | 名称 |   核心特征   |   编程范式   | 与硬件距离 | 关注点 | 典型代表 |
| :-: | :--- | :------: | :------: | :---: | :--- | :--- |
| 1GL | 机器语言 |   二进制指令  |   机器指令   |  直接操作 | 硬件控制 | CPU指令集 |
| 2GL | 汇编语言 |    助记符   |   汇编指令   |  紧密绑定 | 硬件优化 | x86 Assembly |
| 3GL | 高级语言 |   类英语语法  | 过程式/面向对象 |  高度抽象 | 算法与逻辑 | C, Java, Python |
| 4GL | 面向问题语言 | 声明式/特定领域 |   非过程化   |  完全抽象 | 解决特定问题 | SQL, MATLAB |
| 5GL | 人工智能语言 |  约束/逻辑描述 |  声明式/逻辑式 |  意图抽象| 意图理解 | Prolog, AI Code Gen |



### 第一代：机器语言（1GL - First-Generation Language）

**机器语言 (Machine Language)**

*   **核心特征**：计算机唯一能直接理解和执行的语言，纯粹由二进制代码（0 和 1）组成。
*   **工作方式**：直接对 CPU 寄存器和内存地址进行操作，无需任何翻译过程。
*   **优点**：执行速度极快，对硬件的利用率最高。
*   **缺点**：极难编写、阅读和调试；代码不可移植（针对某种 CPU 架构编写的代码在其他架构上完全无法运行）。
*   **代表**：纯二进制机器码。

### 第二代：汇编语言（2GL - Second-Generation Language）

**汇编语言 (Assembly Language)**

*   **核心特征**：使用人类相对易读的“助记符”（Mnemonics，例如 `ADD`, `MOV`, `SUB`）来代替二进制机器指令。
*   **工作方式**：计算机无法直接执行，必须通过一个称为“汇编器（Assembler）”的程序将其翻译成机器语言。
*   **优点**：比机器语言更容易编写和排错，且依然能保持极高的运行效率和底层控制力。
*   **缺点**：依然是面向机器的语言，与具体的 CPU 架构强绑定（如 x86 汇编和 ARM 汇编不通用），开发大型软件效率极低。
*   **代表**：Assembly（汇编语言）。目前仍常用于操作系统内核、驱动程序开发及对性能要求极高的底层模块。

### 第三代：高级语言（3GL - Third-Generation Language）

**高级语言 (High-Level Language)**

*   **核心特征**：引入了更高级的抽象，语法接近人类数学公式和英语，是**目前我们最熟悉、应用最广泛的通用编程语言群体**。
*   **工作方式**：程序员编写源代码，然后通过“编译器（Compiler）”或“解释器（Interpreter）”转化为机器码执行。
*   **优点**：
    *   **可移植性强**：与硬件架构脱钩（如“一次编写，到处运行”）。
    *   支持复杂的数据结构和控制流（循环、条件判断）。
    *   支持结构化编程和面向对象编程（OOP）。
*   **缺点**：需要告诉计算机“如何做”（How to do），即必须编写出详细的算法和逻辑步骤。
*   **代表**：
    *   早期：FORTRAN, COBOL, BASIC, C, Pascal, Delphi
    *   现代主流：C++, Java, Python, JavaScript, Go, Rust, C# 等。

### 第四代：面向问题的语言 / 非过程化语言（4GL - Fourth-Generation Language）

**甚高级语言 / 领域特定语言 (Very High-Level / Domain Specific)**

*   **核心特征**：相比第三代语言，它进一步提升了抽象级别。其核心思想是**“声明式（Declarative）”**——程序员只需告诉计算机“**做什么（What to do）**”，而不需要详细说明“怎么做（How to do）”。
*   **优点**：代码量极少，开发效率极高，通常针对特定的领域（Domain-Specific）。
*   **缺点**：通用性较差，通常只能用于解决特定领域的问题，执行效率有时受限于底层的引擎优化。
*   **代表**：
    *   **数据库查询**：SQL（你只需告诉 SQL“提取这些数据”，不用编写遍历数据库的循环代码）。
    *   **数学与数据分析**：MATLAB, R。
    *   **部分脚本和前端语言**也被认为具有 4GL 特性。

### 第五代：逻辑与人工智能语言（5GL - Fifth-Generation Language）

**自然语言 / 约束式 / AI 语言 (Natural Language / Constraint-based)**

*   **核心特征**：最初是在 20 世纪 80 年代提出，目标是基于**逻辑推理**和**约束求解**。程序员向计算机输入一组“事实（Facts）”和“规则（Rules）”，计算机自动通过逻辑推导得出答案。
*   **设计初衷**：无需编写任何算法，让计算机自己去寻找解决问题的方法，主要用于早期的人工智能研究、专家系统和神经网络。
*   **代表**：Prolog, OPS5, Mercury, LISP（部分分支）。
*   **历史局限**：传统的 5GL 并没有像人们预想的那样取代 3GL 成为主流，因为纯粹的逻辑推理在解决通用软件工程问题时显得十分吃力。

---

### 🌟 补充：未来的“第六代”（AI 大模型时代的编程范式）

> 虽然学术界对“第六代”还没有公认的定义，但在当下的 ChatGPT、GitHub Copilot 和 Claude 等 LLM（大语言模型）时代，编程语言的发展正在出现一种新的形态：

*   **自然语言编程（Prompt Engineering）**：人类使用纯自然语言（如中文、英文）描述需求，AI 自动将其翻译为 3GL 或 4GL 代码并运行。
*   从某种意义上说，这实现了 5GL 当初未能完美实现的愿景——人类真正彻底从“如何做（底层算法）”中解放出来，只需专注于“解决什么问题”。


### 代际划分已经过时

> 值得注意的是，**“第几代语言”这个分类法在现代计算机科学界已经很少使用了**。原因如下：

1.  **界限模糊：** 随着语言发展，Python 或 Java 拥有极其丰富的库，写起来也很像 4GL；而 SQL 也可以嵌入到 3GL 中。
2.  **范式更重要：** 现在大家更倾向于用**编程范式**来分类，例如：
    *   面向对象 (OOP): Java, C#, Delphi
    *   函数式 (Functional): Haskell, Scala, Lisp
    *   脚本语言 (Scripting): Python, JavaScript
    *   系统语言 (Systems): Rust, C, Go



# 第一性原理思维


**第一性原理思维（First Principles Thinking）** 是一种**从本质出发、层层推导**的思维方式，常用于解决问题、创新思考和决策制定。它强调**打破表象、回归基本事实**，然后基于这些不可再拆分的“第一性原理”重新构建解决方案。

---

## 🧠 什么是第一性原理？

### 定义：
> **第一性原理**（First Principle）是指某个领域中最基本、不可再分解的前提或真理。它是推理和判断的基础。

### 第一性原理思维的核心步骤：
1. **识别问题或现状**
2. **质疑现有假设**
3. **拆解为最基本的组成部分（即“第一性原理”）**
4. **从这些基本原理出发，重新构建新的解决方案**

---

## 🔍 举个经典例子：埃隆·马斯克与电池成本

**背景**：传统观念认为电动车太贵是因为电池太贵。
- 普通思路：沿用现有电池价格 → 成本高 → 无法普及
- 马斯克的思路（第一性原理）：

> “电池是由哪些材料组成的？铁、镍、钴、铝等金属元素。如果我直接购买这些原材料，成本是多少？”  
→ 结果发现：原材料成本远低于成品电池的价格。

于是特斯拉开始自己研发和制造电池，大幅降低成本。

---

## 🛠️ 如何应用第一性原理思维？

### 步骤 1：明确你要解决的问题
> 例如：“为什么我们的产品开发周期这么长？”

### 步骤 2：质疑现有假设
> “大家都说流程复杂是正常的”、“我们一直就是这么做的” —— 这些可能是偏见或历史惯性。

### 步骤 3：拆解问题到最基础层面
> 开发周期长可能由以下因素构成：
- 需求评审流程
- 设计沟通效率
- 开发任务分配
- 测试反馈机制
- 上线部署流程

继续追问每个环节的基本原理：
- “需求评审真的需要这么多层级吗？”
- “测试是否必须人工参与每一步？”

### 步骤 4：从底层逻辑重构解决方案
> 基于核心要素重新设计流程：
- 引入自动化测试减少人工等待
- 精简审批流程，采用异步确认机制
- 使用敏捷开发快速迭代

---

## 💡 第一性原理 vs 类比思维

| 思维方式 | 描述 | 特点 | 示例 |
|----------|------|------|------|
| 类比思维 | “别人怎么做我就怎么做” | 快速但易陷入路径依赖 | 看别人做APP我也做APP |
| 第一性原理 | “这件事的本质是什么？我能怎么重新做？” | 缓慢但更具创新性 | 马斯克造火箭、贝佐斯建AWS |

---

## 🎯 适用场景

- 创新突破（如新产品、新技术）
- 复杂问题解决（如系统瓶颈、流程优化）
- 决策制定（如战略方向、投资选择）
- 教育学习（深入理解知识本质）

---

## 📚 相关概念推荐

- **奥卡姆剃刀原则**（Occam’s Razor）：如无必要，勿增实体。
- **5 Why 分析法**：连续问5次“为什么”，找到根本原因。
- **逆向思维 / 反证法**：从结果倒推，验证逻辑是否成立。
- **费曼技巧**：将复杂概念简化表达，检验理解深度。

---

## ✅ 小结：如何训练第一性原理思维？

1. **多问“为什么”**，不接受表面答案
2. **学会拆解问题**，直到不能再拆
3. **尝试重构方案**，从零开始思考
4. **挑战传统做法**，问“这是最优解吗？”
5. **不断练习**：在日常生活中使用（比如做饭、买手机、选课等）

---






---

# 关于工作的意义

不知道大伙有没有想过工作的意义是什么，特别是对于工程师而言。

## 一、工作的基本定义

简单说，工作就是为了获得收入和满足消费而进行的有组织的劳动。既然是有组织的，那么就不是完全自由的，甚至会有不少人觉得是痛苦的。

因此，在19世纪出现了不少“工作最光荣”的理论和社会价值观，用于解决当时人们不愿意去工厂干活的主动性问题。

## 二、如何让工作变得不痛苦，甚至感到幸福？

我理解的答案是：

> **用自己的专业去解决问题、提供服务，并且刚好是自己热爱的事情**，也就是：  
> 做自己喜欢的事情，顺便把钱赚了。

## 三、三种层次的工作幸福感

### ✅ 最幸福的工作
- **特点**：不是别人分配给你的，而是你自己发现的。
- **核心**：结合市场需求与自身擅长，提供解决方案、服务或情绪价值。
- **优势**：能解决你想解决的问题，具有高度自主性和成就感。

### ⚖️ 中等幸福的工作
- **特点**：虽然大方向不受自己控制，但对自己做的事情有一定掌控感。
- **核心**：不是被异化的劳动。
- **目标**：在这个过程中培养能力，逐步向“最幸福的工作”迈进。

### ❌ 不太幸福的工作
- **特点**：做的不是自己想做的事，属于被异化的工作。
- **思考方向**：
  - 这份工作是否可以帮助你摆脱经济束缚？
  - 是否有一个明确的“脱离之日”？
- **策略**：
  - 先解决温饱；
  - 在此过程中积累能力，为未来转型做准备；
  - 目标是转变为中等幸福或最幸福的工作。

---

📌 **总结**：工作的意义不仅是谋生手段，更是实现自我价值、创造社会价值的过程。找到热爱并为之努力，才能真正实现职业上的幸福。

---